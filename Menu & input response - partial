// LCD1602 to Arduino with function parameters and char arrays.
////Dec 2 22:14
// Displaying menus, and moving from one menu item to the next by a single button push
//The code searches the char array looking for the next menu item, finds it and places the cursor under the first letter
//This skips menu items of any length and empty spaces.
//1 press of "left" or "right" button skips to the next menu item
//Direction is controlled through A0 (for test using pot) "left" or "right" button skips to the next menu item
//As a test if it finds the "Color" label the menu is changed from the Main menu to the Color menu
//Dec 1
// Have state of menu. Function prints the relevant menu based on state.
//need expand the function that changes state of menu based on label selected




#include <LiquidCrystal.h>
///////////////////// LED indicators which are not needed. They show inner working of search wihtin menus
#define labelLED 2 
#define spaceLED 3
#define textLED 4

enum stateOfbutton_t {unknown, select, left, up, down, RIGHT};// 5 push button inputs read by analogue voltage
//The values read in the function were set on a simulator & will need to be changed to match the actual buttons/voltages

enum stateOfMenu_t 
{MenuUnknown, 
showMain1, 
show2Color, show2Flicker, show2Day,show2OnOff, // level 2 of hierarchy of menu
show3Flicker, show3Day, show3OnOff,            // level 3
showNoMenu};


LiquidCrystal lcd(12, 11, 10, 9, 8, 7);// This is set on a simulator. May not theyMatch the actual hardware<<<<<

stateOfbutton_t buttonState=unknown;// buttonState is used in other parts of the software


///////////////////// The hierachy of menus for user input

char menu1Main []   {"MAIN Flicker Day Color OnOff EXIT"};//has an extra space between day & color to separate them, but that 1 space is not shown on LCD
                //    0123456789ABCDEF0123456789ABCDEF0 =33 elements

char menu2Color[]   {"COLOR: >OUT<     Select_LED  EXIT"}; // this is a 2nd level menu 
                //    0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu2Flicker[] {"FLICKER: >OUT<   Select_LED  EXIT"}; // this is a 2nd level menu 
                //    0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu2Day[]     {"DAY: Length>OUT< up/down     EXIT"}; // this is a 2nd level menu 
                  //  0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu2OnOff[]   {"ONOFF:Select_LED >OUT< onOff EXIT"}; // this is a 2nd level menu 
                  //  0123456789ABCDEF0123456789ABCDEF0 =33 elements

char menu3Color[]   {"ROTATE:  >OUT<               EXIT"}; // this is a 2nd level menu 
                  //  0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu3Flicker[] {"Speed Depth >OUT Chance      EXIT"}; // this is a 2nd level menu 
                  //  0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu3OnOff[]   {"Speed Chance    >OUT< >OUT< EXIT"}; // this is a 2nd level menu 
                  //  0123456789ABCDEF0123456789ABCDEF0 =33 elements




stateOfMenu_t menuState = MenuUnknown;

bool row=1;  //test only
int startColumn=12 ;//TEST ONLY. Could start with 12,1 as the place where Exit is on lcd
int labelPosition;
char thisLabel[10];

char* menu_ptr=menu1Main;// Not sure if it should start with this value




///////////////////// Put the curso in position and wait so that user can see it move  

void displayCursor(int col, bool row){
lcd.setCursor(col,row);
delay(500); // the delay is just here so the movement of the cursor can be seen for testing
}


 
///////////////////// Read the Menu Label using the known position in the menu array. (So can understand what to do)

char readMenuLabel(char *menu, int labelStart){
 //lcd.print(labelStart);delay(1000);
  //char thisLabel[10]; //is that big enough for any of the labels?
// if(labelStart==0 ) thisLabel[0]='\0'; //ignore the first label which is at positin 0,0. It's the menu title
// else{
   for(int i=labelStart;i<34;i++){//menu has 33 characters including 1 non-printing space separating the rows
    thisLabel[i-labelStart] = menu[i];
    if( menu[i]==' ') { //the first space found is the end of the label. Not here if already past end of menu
    //what if label is EXIT? that is last thing in menu  i=33. Menu 34 = null?
      thisLabel[i-labelStart]='\0';
      break;
  //  }
//  lcd.print(thisLabel);
}
 
 }
//lcd.setCursor(0,0);//lcd.print(":"); /
 //lcd.clear();
 //lcd.print(thisLabel); //TEST
return thisLabel;
}
 

///////////////////// theyMatch char arrays 

int theyMatch(char a[],char b[]){
    for(int i=0;a[i]!='\0';i++){
      if (i>10) break;//my limit size
        if(a[i]!=b[i])
            return 0;
    }
    return 1;
}

///////////////////// use the label in the menu to set the menustate so that the correct one will be printed
 
int useLabelToSetMenuState(){//when select button pressed?

//lcd.print (theyMatch(thisLabel , "Color"));//returning 0 always
//lcd.print(thisLabel);
//if(theyMatch(thisLabel , "Color")) {menu_ptr=menu2Color; PrintMenu(menu_ptr);}//MOVE the print

if(theyMatch(thisLabel , "Color")) {menuState = show2Color;}//doesn't change the menu

else
//if(theyMatch(thisLabel , "Flicker")) {menu_ptr=menu2Flicker; PrintMenu(menu_ptr);}//MOVE the print
if(theyMatch(thisLabel , "Flicker")) {menuState = show2Flicker;}//
else
if(theyMatch(thisLabel , "Day")) {menuState = show2Day;}//
else
if(theyMatch(thisLabel , "OnOff")) {menuState = show2OnOff;}//
else
//

if(theyMatch(thisLabel , "EXIT")) {exitToPreviousMenu();}//

 //??? 
}


///////////////////// EXIT was selected. Move to previous menu level or leave the menus & return to LED routine

void exitToPreviousMenu(){
 lcd.setCursor(0,0); lcd.print("Exit to previous"); //

 //switch (menuState){
  // case: 
//If was main menu 
//set menu state to none
//clear LCD
//Print the name
 // Set system state back to active.

//case 
//if a level 2 menu go to main
//if level 3 go to relevant level 2
 }



///////////////////// Look for next label to LEFT in current menu               Difference: decrement index, How handle end of LCD display, order of skip

int8_t FindLabelLeft(char *menu ){  // Return value is used to set labelPosition. 

 //assuming 12,1 is where EXIT is displayed
//lcd.setCursor(12,1);//????????????????????????????????????/

int i=startColumn;
displayCursor(i, row);
lcd.cursor();// make cursor visible

if(i==0) {i=15; row = !row;}//if at start of LCD row change output to be end of other row
else {//lcd.setCursor(5,1);lcd.print(i);
while(menu[i+(row*17)]!= ' ') //skip spaces
{ i--;
if(i<=0) {i=15; row = !row;}// if reached start of row move to other row end =15
displayCursor(i, row);}
}
//found space between first lable and label to the left
digitalWrite(spaceLED, HIGH);
//delay(1000);
while(menu[i+(row*17)] == ' ')
{i--; if(i<=0) {i=15; row = !row;}// move to other row far right col =15
 displayCursor(i, row);} //skip through blank spaces bewteen labels.
 //Now found end of left label
 digitalWrite(textLED, HIGH);digitalWrite(spaceLED, LOW);
//delay(1000);
 
while(menu[i+(row*17)]!= ' ' && i>0)//skip text until find the next space
{ i--;
 displayCursor(i, row);
}// skip through the left label till find space OR i=0 Label begins at 0 or at i+1
 //Now found label to the left
 digitalWrite(labelLED, HIGH);digitalWrite(textLED, LOW);
if(i<=0) startColumn=0; else startColumn = i+1;  //The label was one column to the right, except at 0
 lcd.setCursor(startColumn,row);
//lcd.print(startColumn); delay(2000);lcd.print((startColumn+(row*17)));
return (startColumn+(row*17)); // not sure how this will be used - respond to SELECT button
//when (0,0) this returns 17 which is 16 top row + 1 not displayed space in the array
//top row is (0,0)==0 to  (15,0)==15 [added space 16] then
//bottom row (0,1)==17 to (15,1)==32
}





///////////////////// find next label to RIGHT in menu    (Difference: increment index, How handle end of LCD display, order of skip

int FindLabelRight(char *menu){ //can left & right be combined? // Return value is used to set labelPosition. 

int i=startColumn;
displayCursor(i, row);
lcd.cursor();// make cursor visible
//delay(500);

digitalWrite(textLED, HIGH);//already on text
if(i==15) {i=0; row = !row;}//if at end of LCD row, change to start of other row
else {//lcd.setCursor(5,1);lcd.print(i);
while(menu[i+(row*17)]!= ' ' && i<16)//skip text, but not past end of row
{ i++;  //lcd.setCursor(0,1);lcd.print(i);//????
//displayCursor(i, row);delay(1000);
if(i>15) {i=0; row = !row; break;}// move to other row far left col =0
displayCursor(i, row);}
delay(200);//just to make cursor movement visible.
}
//found space between first label and label to the right
digitalWrite(spaceLED, HIGH);
//delay(500);
  
while(menu[i+(row*17)] == ' ')//skip spaces
{i++; if(i>15) {i=0; row = !row;}// move to other row far right col =15
 displayCursor(i, row);
 
  } //skip through blank spaces bewteen labels.
 
 
 //Now found start of right label
digitalWrite(textLED, HIGH);digitalWrite(spaceLED, LOW);
delay(100);
digitalWrite(labelLED, HIGH);//digitalWrite(textLED, LOW);

displayCursor(i, row);


startColumn =i;//reset for the next movement from this point
return (i+(row*17)); // not sure how this will be used - respond to SELECT button
//probably need to return the position in array not the col position on LCD

}



///////////////////// react To ButtonState Find Label Or Change Menu

int reactToButtonStateFindLabelOrChangeMenu(){
 switch (buttonState){
case unknown: break;
case left:return FindLabelLeft(menu_ptr); break;//returns (i+(row*17));giving 18 should be 16
case RIGHT: return FindLabelRight(menu_ptr); break; // (i+(row*17));
case select: useLabelToSetMenuState(); break; // what to do?
 
default: return 0;
}
}


/////////////////////  print the chosen menu

void PrintMenu(char *menu ){
 int offset=0;
 for (uint8_t row = 0; row<2; row++){
  for(uint8_t i=0;i<16;i++){
  lcd.setCursor(i,row);//first 0-15 prints top row. then need skip one space in file to then print the second row
  offset = row * (17)+i; //the menu has an extra space in between upper & lower row that LCD doesn't have
  lcd.print(menu+offset) ;
  //delay(100);
  }
 }
}

/*
enum stateOfMenu_t 
{MenuUnknown, 
showMain1, 
show2Color, show2Flicker, show2Day,show2OnOff, 
show3Flicker, show3OnOff,
showNoMenu};
*/

///////////////////// Display menu based on menu state

void DisplayMenuBasedOnMenuState(){

switch (menuState){

  case showNoMenu://menu_ptr=nullptr; 
  break;//does this cause problems?

  case MenuUnknown: //menu_ptr=nullptr; 
  break;//does this cause problems?

  case showMain1: menu_ptr = menu1Main; break;

  case show2Color:menu_ptr = menu2Color; break;

  case show2Flicker:menu_ptr = menu2Flicker; break;
 
  case show2Day: menu_ptr = menu2Day; break;
  
  case show2OnOff: menu_ptr = menu2OnOff; break;
 
  case show3Flicker:menu_ptr = menu3Flicker; break;

  case show3OnOff: menu_ptr = menu3OnOff; break;

 } 

PrintMenu(menu_ptr);
};



///////////////////// Respond to user


void respondToUser(){ //if any button, set lights to 'idle' or stay out of system loop? 

DisplayMenuBasedOnMenuState();    
if (analogRead(A0) <400) buttonState=left;// need change to match shield<<<<<<<<<<<<<
else if(analogRead(A0)<800) buttonState=RIGHT;
else if(analogRead(A0)>900) buttonState=select;
//for(int i=0;i<7;i++){
  digitalWrite(2 , LOW);
  digitalWrite(3 , LOW);
  digitalWrite(4 , LOW);

int labelPosition = reactToButtonStateFindLabelOrChangeMenu();
readMenuLabel(  menu_ptr,labelPosition);//shouldn't call it here?
//depends on which menu is displayed?
delay(500);


delay(500);

 }


///////////////////// setup

void setup() {
pinMode (2, OUTPUT); //digitalWrite(spaceLED, HIGH); // indicators which probably won't be in finished product
pinMode (3, OUTPUT); //digitalWrite(textLED, HIGH);
pinMode (4, OUTPUT); //digitalWrite(labelLED, HIGH);

lcd.begin(16, 2);
Serial.begin(115200);
Serial.println("Where?");
//Assuming a button has been pressed and the reaction is to set...
menuState = showMain1;//TEST only - Normally only get to this stage when button pressed <<<<<<<<<<
}

///////////////////// Loop

void loop() {


         //this loop should be separate from main LED loop or the other parts just idle?
respondToUser();// not sure which should be in this loop
//when 'select' the cursor goes all over the LCD  Need to check why. 
delay(100);//just here for test
}
 
