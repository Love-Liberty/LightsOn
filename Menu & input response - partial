// LCD1602 to Arduino with function parameters and char arrays.
////Dec 5 22:36
// Displaying menus, and moving from one menu item to the next by a single button push
// The code searches the char array looking for the next menu item, finds it and places the cursor under the first letter
// This skips menu items of any length and empty spaces.
// 1 press of "left" or "right" button skips to the next menu item
// Direction is controlled through A0 (for test using pot) "left" or "right" button skips to the next menu item
// As a test if it finds the "Color" label the menu is changed from the Main menu to the Color menu
// Dec 1
// Have state of menu. Function prints the relevant menu based on state.
// need expand the function that changes state of menu based on label selected
//Can move through much of menu to other levels. Pr5obably too complicated and takes up too much space.

#include <Arduino.h>

#include <LiquidCrystal.h>
///////////////////// LED indicators which are not needed. They show inner working of search wihtin menus
#define labelLED 2
#define spaceLED 3
#define textLED 4

enum stateOfbutton_t
{
  unknown,
  select,
  left,
  down,
  up,
  RIGHT
}; // 5 push button inputs read by analogue voltage
// The values read in the function were set on a simulator & will need to be changed to match the actual buttons/voltages

enum stateOfMenu_t
{
  MenuUnknown,
  showMain1,
  show2Color,
  show2Flicker,
  show2Day,
  show2OnOff, // level 2 of hierarchy of menu
  show3Flicker,
  show3Day,
  show3OnOff, // level 3
  showNoMenu
};

// LiquidCrystal lcd(12, 11, 10, 9, 8, 7); // This is set on a simulator. May not theyMatch the actual hardware<<<<<

const int rs = 8, en = 9, d4 = 4, d5 = 5, d6 = 6, d7 = 7; // the read/write pin not connected
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

stateOfbutton_t buttonState = unknown; // buttonState is used in other parts of the software

///////////////////// The hierachy of menus for user input


char projectName[] {"   LightsOn!                     "}; // has an extra space between day & color to separate them, but that 1 space is not shown on LCD
           //        0123456789ABCDEF0123456789ABCDEF0 =33 elements

char menu1Main[]   {"MAIN Flicker Day Color OnOff EXIT"}; // has an extra space between day & color to separate them, but that 1 space is not shown on LCD
           //        0123456789ABCDEF0123456789ABCDEF0 =33 elements

char menu2Color[]  {"COLOR: >OUT<     Select_LED  EXIT"};   // this is a 2nd level menu
             //      0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu2Flicker[]{"FLICKER: >OUT<   Select_LED  EXIT"}; // this is a 2nd level menu
               //    0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu2Day[]    {"DAY: Length>OUT< up/down     EXIT"};     // this is a 2nd level menu
             //      0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu2OnOff[]  {"ONOFF Select_LED >OUT< ONOff EXIT"};   // this is a 2nd level menu
               //    0123456789ABCDEF0123456789ABCDEF0 =33 elements

char menu3Color[]  {"ROTATE:  >OUT<               EXIT"};   // this is a 2nd level menu
               //    0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu3Flicker[]{"Speed Depth >OUT Chance      EXIT"}; // this is a 2nd level menu
               //    0123456789ABCDEF0123456789ABCDEF0 =33 elements
char menu3OnOff[]  {"Speed Chance     >OUT< >OUT< EXIT"};    // this is a 2nd level menu
               //    0123456789ABCDEF0123456789ABCDEF0 =33 elements

stateOfMenu_t menuState = MenuUnknown; // before an input button is clicked

bool row = 1;           // test only
int startColumn = 12;   // TEST ONLY. Could start with 12,1 as the place where Exit is on lcd
int labelPosition = 29; // set where EXIT label is expected to be = column 12 + 17.  12 is the column in the LCD but the text is in an array at [29]
char thisLabel[10] = "EXIT";

char *menu_ptr = projectName; // Not sure if it should start with this value

//////////////////// utilities for debug //////////////////////////////////////

int readButtonPrintDataUtility() // not called in normal program
{
  static int min = 5000, max = 0; // set as obviously wrong because going to measure min and max of button reading. The down button is faulty
  // buttonState_t stateOfbutton;
  int buttonValue = analogRead(A0);
  // if (buttonValue < 950)
  { // ignore the "no button" value of 1023

    if (buttonValue > max)
      max = buttonValue;
    if (buttonValue < min)
      min = buttonValue;

    Serial.print(" min: ");
    Serial.print(min);
    Serial.print(" read= ");
    Serial.print(buttonValue);
    Serial.print(" max: ");
    Serial.print(max);
    Serial.print(" ");
  }

  /*
  lcd.setCursor(0,0);
  lcd.print("min");
  lcd.setCursor(5,0);
  lcd.print("Value");
  lcd.setCursor(10,0);
  lcd.print("max");



  lcd.setCursor(0,1);
  lcd.print(min);
  lcd.setCursor(5,1);
  lcd.print(buttonValue);
  lcd.setCursor(10,1);
  lcd.print(max);
  */
  // stateOfbutton = checkButtonPressedReturn0To6();
  // Serial.print(" StaeOfButton:");
  // Serial.print(stateOfbutton);

  return buttonValue;
}

void printProjectName()
{lcd.setCursor(0,0);
menu_ptr = projectName;
lcd.print(menu_ptr);
lcd
//  lcd.setCursor(3, 0); // (column, row)
  // lcd.autoscroll();
  //lcd.print("LightsOn!");
}

///////////////////// Put the curso in position and wait so that user can see it move

void displayCursor(int col, bool row)
{
  lcd.setCursor(col, row);   lcd.cursor();
  delay(400); // the delay is just here so the movement of the cursor can be seen for testing
}

///////////////////// Read the Menu Label using the known position in the menu array. (So can understand what to do)

void readMenuLabel(char *menu, int labelStart)
{
  // lcd.print(labelStart);delay(1000);
  // char thisLabel[10]; //is that big enough for any of the labels?
  // if(labelStart==0 ) thisLabel[0]='\0'; //ignore the first label which is at positin 0,0. It's the menu title
  // else{
  for (int i = labelStart; i < 34; i++)
  { // menu has 33 characters including 1 non-printing space separating the rows
    thisLabel[i - labelStart] = menu[i];
    if (menu[i] == ' ')
    { // the first space found is the end of the label. Not here if already past end of menu
      // what if label is EXIT? that is last thing in menu  i=33. Menu 34 = null?
      thisLabel[i - labelStart] = '\0';
      break;
      //  }
      //  lcd.print(thisLabel);
    }
  }
  // lcd.setCursor(0,0);//lcd.print(":"); /
  // lcd.clear();
  // lcd.print(thisLabel); //TEST
  // return thisLabel;
}

///////////////////// theyMatch char arrays

int theyMatch(char a[], char b[])
{
  for (int i = 0; a[i] != '\0'; i++)
  {
    if (i > 10)
      break; // my limit size
    if (a[i] != b[i])
      return 0;
  }
  return 1;
}


void resetCursorArrayPositionsToLabelExit(){

 labelPosition = 29; startColumn = 12; row = 1;// reset to fit EXIT position But is doesn't.... ? Entry into new menu seems to change the p
 strcpy(thisLabel, "EXIT");

}


///////////////////// EXIT was selected. Move to previous menu level or leave the menus & return to LED routine

void exitToPreviousMenu()
{
  //lcd.setCursor(0, 0);
  //lcd.print("Exit to previous"); //

  switch (menuState) {
    
  case MenuUnknown: Serial.print("exitToPrevious-MenuUnknwon"); break;  
  case showMain1: menuState=showNoMenu;  Serial.print(" showMain > showNoMenu "); delay(1000);break; // Getting reversed later??
  case show2Color: menuState = showMain1; break;
  case show2Flicker: menuState = showMain1; break;
  case show2OnOff: menuState = showMain1; break;
  case show2Day: menuState = showMain1; break;

  case show3Flicker: menuState = show2Flicker; break;
  case show3Day: menuState = show2Day; break;
  case show3OnOff: menuState = show2OnOff; break;
  
  
  case showNoMenu: Serial.print(" case showNoMenu"); delay(1000); break;//doesn't come here?
  
  }


  // switch (menuState){
  //  case:
  // If was main menu
  // set menu state to none
  // clear LCD
  // Print the name
  //  Set system state back to active.

  // case
  // if a level 2 menu go to main
  // if level 3 go to relevant level 2
}

///////////////////// use the label in the menu to set the menustate so that the correct one will be printed

void useLabelToSetMenuState()
{ // when select button pressed?  //ISO forbids changing a string constant to char
  // lcd.print (theyMatch(thisLabel , "Color"));
  // if(theyMatch(thisLabel , "Color")) {menu_ptr=menu2Color; PrintMenu(menu_ptr);}//compiler refused

  char labelColor[]{"Color"}, labelFlicker[]{"Flicker"}, labelDay[]{"Day"}, labelOnOff[]{"OnOff"}, labelEXIT[]{"EXIT"};

  if (theyMatch(thisLabel, labelColor))
  {
    menuState = show2Color; resetCursorArrayPositionsToLabelExit();
  } // doesn't change the menu

  else

    if (theyMatch(thisLabel, labelFlicker))
    {
      menuState = show2Flicker; resetCursorArrayPositionsToLabelExit();
    } //
    else if (theyMatch(thisLabel, labelDay))
    {
      menuState = show2Day; resetCursorArrayPositionsToLabelExit();
    } //
    else if (theyMatch(thisLabel, labelOnOff))
    {
      menuState = show2OnOff; resetCursorArrayPositionsToLabelExit();
    } //
    else
      //

      if (theyMatch(thisLabel, labelEXIT))
      {
        exitToPreviousMenu(); resetCursorArrayPositionsToLabelExit();
      } //

  
}

///////////////////// Look for next label to LEFT in current menu               Difference: decrement index, How handle end of LCD display, order of skip

int8_t FindLabelLeft(char *menu)
{ // Return value is used to set labelPosition.

  // assuming 12,1 is where EXIT is displayed
  // lcd.setCursor(12,1);//???????????????

  int i = startColumn;
  displayCursor(i, row);
  lcd.cursor(); // make cursor visible

  if (i == 0)
  {
    i = 15;
    row = !row;
  } // if at start of LCD row change output to be end of other row
  else
  {                                     // lcd.setCursor(5,1);lcd.print(i);
    while (menu[i + (row * 17)] != ' ') // skip spaces
    {
      i--;
      if (i <= 0)
      {
        i = 15;
        row = !row;
      } // if reached start of row move to other row end =15
      displayCursor(i, row);
    }
  }
  // found space between first lable and label to the left
  digitalWrite(spaceLED, HIGH);
  // delay(1000);
  while (menu[i + (row * 17)] == ' ')
  {
    i--;
    if (i <= 0)
    {
      i = 15;
      row = !row;
    } // move to other row far right col =15
    displayCursor(i, row);
  } // skip through blank spaces bewteen labels.
  // Now found end of left label
  digitalWrite(textLED, HIGH);
  digitalWrite(spaceLED, LOW);
  // delay(1000);

  while (menu[i + (row * 17)] != ' ' && i > 0) // skip text until find the next space
  {
    i--;
    displayCursor(i, row);
  } // skip through the left label till find space OR i=0 Label begins at 0 or at i+1
  // Now found label to the left
  digitalWrite(labelLED, HIGH);
  digitalWrite(textLED, LOW);
  if (i <= 0)
    startColumn = 0;
  else
    startColumn = i + 1; // The label was one column to the right, except at 0
  lcd.setCursor(startColumn, row);
  // lcd.print(startColumn); delay(2000);lcd.print((startColumn+(row*17)));
  return (startColumn + (row * 17)); // not sure how this will be used - respond to SELECT button
  // when (0,0) this returns 17 which is 16 top row + 1 not displayed space in the array
  // top row is (0,0)==0 to  (15,0)==15 [added space 16] then
  // bottom row (0,1)==17 to (15,1)==32
}

///////////////////// find next label to RIGHT in menu    (Difference: increment index, How handle end of LCD display, order of skip

int FindLabelRight(char *menu)
{ // can left & right be combined? // Return value is used to set labelPosition.

  int i = startColumn;
  displayCursor(i, row);
  lcd.cursor(); // make cursor visible
  // delay(500);

  digitalWrite(textLED, HIGH); // already on text
  if (i == 15)
  {
    i = 0;
    row = !row;
  } // if at end of LCD row, change to start of other row
  else
  {                                               // lcd.setCursor(5,1);lcd.print(i);
    while (menu[i + (row * 17)] != ' ' && i < 16) // skip text, but not past end of row
    {
      i++; // lcd.setCursor(0,1);lcd.print(i);//????
      // displayCursor(i, row);delay(1000);
      if (i > 15)
      {
        i = 0;
        row = !row;
        break;
      } // move to other row far left col =0
      displayCursor(i, row);
    }
    //delay(200); // just to make cursor movement visible.
  }
  // found space between first label and label to the right
  digitalWrite(spaceLED, HIGH);
  // delay(500);

  while (menu[i + (row * 17)] == ' ') // skip spaces
  {
    i++;
    if (i > 15)
    {
      i = 0;
      row = !row;
    } // move to other row far right col =15
    displayCursor(i, row);

  } // skip through blank spaces bewteen labels.

  // Now found start of right label
  digitalWrite(textLED, HIGH);
  digitalWrite(spaceLED, LOW);
 // delay(100);
  digitalWrite(labelLED, HIGH); // digitalWrite(textLED, LOW);

  displayCursor(i, row);

  startColumn = i;         // reset for the next movement from this point
  return (i + (row * 17)); // not sure how this will be used - respond to SELECT button
  // probably need to return the position in array not the col position on LCD
}

///////////////////// react To ButtonState Find Label Or Change Menu

int reactToButtonStateFindLabelOrChangeMenu()
{ 

  switch (buttonState)
  {
  case unknown:
    break;

  case left:
  labelPosition = FindLabelLeft(menu_ptr);
  readMenuLabel(menu_ptr, labelPosition); 
  break; // returns (i+(row*17));giving 18 should be 16
  
  case RIGHT:
    
    labelPosition = FindLabelRight(menu_ptr);
    readMenuLabel(menu_ptr, labelPosition); 
    break; // (i+(row*17));

  case select:
    useLabelToSetMenuState();
    break; // what to do?

  default:

    break;
  }
  return labelPosition;
}

/////////////////////  print the chosen menu

void PrintMenu(char *menu)
{
  int offset = 0;
  for (uint8_t row = 0; row < 2; row++)
  {
    for (uint8_t i = 0; i < 16; i++)
    {
      lcd.setCursor(i, row);   // first 0-15 prints top row. then need skip one space in file to then print the second row
      offset = row * (17) + i; // the menu has an extra space in between upper & lower row that LCD doesn't have
      lcd.print(menu + offset);
      // delay(100);
    }
  }
}

/*
enum stateOfMenu_t
{MenuUnknown,
showMain1,
show2Color, show2Flicker, show2Day,show2OnOff,
show3Flicker, show3OnOff,
showNoMenu};
*/

///////////////////// Display menu based on menu state

void DisplayMenuBasedOnMenuState()
{
  if (menuState != MenuUnknown) // only print the menu if required
  {
    /* code */

    switch (menuState)
    {

    case showNoMenu:  menu_ptr = projectName; // menu_ptr=nullptr;// may need to make thisLabel = blanck and switch off the cursor?
      break;         // does this cause problems?

    case MenuUnknown: //  menu_ptr = projectName;   // menu_ptr=nullptr;
      break;          // does this cause problems? Yes it prints junk if use nullptr

    case showMain1:
      menu_ptr = menu1Main;
      break;

    case show2Color:
      menu_ptr = menu2Color;
      break;

    case show2Flicker:
      menu_ptr = menu2Flicker;
      break;

    case show2Day:
      menu_ptr = menu2Day;
      break;

    case show2OnOff:
      menu_ptr = menu2OnOff;
      break;

    case show3Flicker:
      menu_ptr = menu3Flicker;
      break;

    case show3OnOff:
      menu_ptr = menu3OnOff;
      break;
    case show3Day:
      break;
    }

    PrintMenu(menu_ptr); // always prints a memnu or thwe project name. oddly it prints both rows from here but only top row in print project name ()
 {
  lcd.setCursor(startColumn, row);   lcd.cursor();//displayCursor(startColumn, row);
lcd.print(thisLabel);  lcd.setCursor(startColumn, row);// if print thisLabel the cursor ends up in wrong place after label but can it be put back? YES!
//also prints exit when showing the project name
 }


  }
};

///////////////////// Respond to user

void respondToUser()
{ // if any button, set lights to 'idle' or stay out of system loop?
  // only comes here if a button is pressed
  //does it need to be turned on in this function as well as the search L&R ?
 //for (int i = 0; i < 8; i++)
   Serial.print(" A0= ");
  Serial.print(analogRead(A0));

  Serial.print(" buttonState= ");
  Serial.print(buttonState);
  Serial.print(" ");
  Serial.print(" menuState= ");
  Serial.print(menuState);
  Serial.print(" ");

  if (menuState == MenuUnknown) // first call to this function.
  {                             // get ready to display the main menu but ignore which button was pressed
    menuState = showMain1; lcd.cursor(); // not visible
  } // don't respond further to first button press
  else
  { // if not first button press do respond to it
  lcd.cursor();
    if (analogRead(A0) > 900)
      buttonState = unknown; // 1023 when no button pressed
    else if (analogRead(A0) > 500)
      buttonState = select; // 640/641  <---- need act on this<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    else if (analogRead(A0) > 380)
      buttonState = left; // 412/413
    else if (analogRead(A0) > 220)
      buttonState = down; // 259/260
    else if (analogRead(A0) > 90)
      buttonState = up; // 102/103
    else if (analogRead(A0) < 10)
      buttonState = RIGHT; // 0/0
  }



  Serial.print(" After switch ");
  Serial.print(" menuState= ");
  Serial.print(menuState);
  Serial.print(" ");

  // for(int i=0;i<7;i++){
  digitalWrite(2, LOW);
  digitalWrite(3, LOW);
  digitalWrite(4, LOW);
if (menuState==showNoMenu) //the user recently clicked EXIT, the project name is displayed. The finger may still be on the button. Don't respond yet
{ menuState = MenuUnknown; buttonState = unknown; // don't react to button (if left it would search in project name and then display main. Cute but select doesn't cause main to be displayed)
  /* code */
} // 
else {
 reactToButtonStateFindLabelOrChangeMenu(); // this used to be under the next call 21:05 dec 4-
  DisplayMenuBasedOnMenuState(); // always check to print a menu if menuState says so
  

}
//need decision here about what to do.

// move below to that function?
//  int labelPosition = reactToButtonStateFindLabelOrChangeMenu();
//  readMenuLabel(menu_ptr, labelPosition); // shouldn't call it here?


  Serial.print(" labelPosition= ");
  Serial.print(labelPosition);
  Serial.print(" thisLabel= ");
  Serial.println(thisLabel);

  // depends on which menu is displayed?
  // delay(500);

  // delay(500);
}

///////////////////// setup

void setup()
{
  pinMode(2, OUTPUT); // digitalWrite(spaceLED, HIGH); // indicators which probably won't be in finished product
  pinMode(3, OUTPUT); // digitalWrite(textLED, HIGH);
  pinMode(4, OUTPUT); // digitalWrite(labelLED, HIGH);

  lcd.begin(16, 2);
  Serial.begin(9600);
//menuState = showNoMenu; //initialised at top of code
  // Assuming a button has been pressed and the reaction is to set...
  printProjectName();//this seems to print just the top row, but later call prints both ????
  //  menuState = showMain1; // TEST only - Normally only get to this stage when button pressed <<<<<<<<<<
}

///////////////////// Loop

void loop()
{
  // checkIfAnyButtonPressed();
  if (analogRead(A0) < 1000)
    // readButtonPrintDataUtility();
    //  this loop should be separate from main LED loop or the other parts just idle?
    respondToUser(); // not sure which should be in this loop
  // when 'select' the cursor goes all over the LCD  Need to check why.
  delay(100); // just here for test
}
